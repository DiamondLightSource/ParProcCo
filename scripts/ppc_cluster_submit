#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations

import argparse
import datetime
import logging
import re
from getpass import getuser
from typing import List

from ParProcCo.job_controller import JobController
from ParProcCo.passthru_wrapper import PassThruWrapper
from ParProcCo.utils import get_token, set_up_wrapper

SLURM_VERSION = "0.0.38"


def create_parser() -> argparse.ArgumentParser:
    """
    $ ppc_cluster_submit program [--partition cs05r] [--token path/to/token/file] [--output cluster_output_dir]
     [--jobs 4] [--timeout 1h30m] --memory 4000 --cores 6 -s 0.01 ... [input files]
    """
    parser = argparse.ArgumentParser(
        description="ParProcCo run script",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "--partition",
        help="str: partition on which to run jobs",
        type=str,
        required=True,
    )
    parser.add_argument(
        "--token", help="str: slurm token filepath", type=str, required=True
    )
    parser.add_argument("-o", "--output", help="str: cluster output file or directory")
    parser.add_argument(
        "--jobs",
        help="int: number of cluster jobs to split processing into",
        type=int,
        default=1,
    )
    parser.add_argument(
        "--timeout",
        help="str: timeout for cluster jobs to finish - xxh[yym]",
        default="2h",
    )
    parser.add_argument(
        "--memory",
        help="int: memory to use per cluster job (MB)",
        type=int,
        required=True
    )
    parser.add_argument(
        "--cores",
        help="int: number of cores to use per cluster job",
        type=int,
        required=True,
    )
    parser.add_argument(
        "-D", "--debug", help="show debugging information", action="store_true"
    )
    return parser


TIMEOUT_PATTERN = re.compile(
    r"^((?P<hours>\d+)h)?((?P<minutes>\d+)m)?$", re.I
)  # @UndefinedVariable


def parse_timeout(timeout: str) -> datetime.timedelta:
    mo = TIMEOUT_PATTERN.match(timeout.strip())
    if not mo:
        raise ValueError(f"Could not parse {timeout} as time interval")
    to_dict = {
        k: int(v) for k, v in mo.groupdict().items() if v is not None
    }  # filter out None-valued items
    logging.debug("Parsed time as %s", to_dict)
    return datetime.timedelta(**to_dict)


def run_ppc(args: argparse.Namespace, script_args: List) -> None:
    """
    Run JobController
    """
    from ParProcCo.utils import load_cfg

    cfg = load_cfg()
    url = cfg.url
    token = get_token(args.token)
    user = getuser()

    extra_properties = None
    if cfg.extra_property_envs:
        extra_properties = {}
        logging.debug("Extra job properties:")
        for k,e in cfg.extra_property_envs:
            v = os.getenv(e)
            logging.debug("\t%s: %s", k, v)
            if v:
                extra_properties[k] = v

    timeout = parse_timeout(args.timeout)
    logging.info("Running for with timeout %s", timeout)

    if not script_args:
        raise ValueError("No script and any of its arguments given")

    program = script_args[0]
    if args.jobs >= 1:
        wrapper = set_up_wrapper(cfg, program)
        if args.jobs == 1:
            wrapper = PassThruWrapper(wrapper)
    else:
        raise ValueError(f"Number of jobs must be one or more, given {args.jobs}")
    wrapper.set_cores(args.cores)
    output = wrapper.get_output(args.output, script_args[1:])
    wrapper_args = wrapper.get_args(script_args, args.debug)
    jc = JobController(
        url,
        wrapper,
        output,
        args.partition,
        extra_properties,
        SLURM_VERSION,
        user,
        token,
        timeout,
    )
    jc.run(args.jobs, wrapper_args, args.memory, "PPC-" + program)
    print("complete")


if __name__ == "__main__":
    args, script_args = create_parser().parse_known_args()
    logging.getLogger().setLevel(logging.DEBUG if args.debug else logging.INFO)
    run_ppc(args, script_args)
